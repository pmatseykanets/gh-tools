package main

import (
	"bytes"
	"io"
	"reflect"
	"regexp"
	"testing"
)

func TestGrep(t *testing.T) {
	tests := []struct {
		desc    string
		input   []byte
		regex   *regexp.Regexp
		limit   int
		results *grepResults
	}{
		{
			desc:    "nil reader",
			regex:   regexp.MustCompile("foo"),
			results: &grepResults{},
		},
		{
			desc:    "nil regex",
			input:   []byte("foo"),
			results: &grepResults{},
		},
		{
			desc:  "exact match",
			input: []byte("foo"),
			regex: regexp.MustCompile("foo"),
			results: &grepResults{
				matches: []grepMatch{
					{line: "foo", lineno: int64(1)},
				},
			},
		},
		{
			desc:  "single match",
			input: []byte("\nfoo\nbar\n"),
			regex: regexp.MustCompile("foo"),
			results: &grepResults{
				matches: []grepMatch{
					{line: "foo", lineno: int64(2)},
				},
			},
		},
		{
			desc:  "multiple matches",
			input: []byte("\nfoobar\nbarfoo\n"),
			regex: regexp.MustCompile("foo"),
			results: &grepResults{
				matches: []grepMatch{
					{line: "foobar", lineno: int64(2)},
					{line: "barfoo", lineno: int64(3)},
				},
			},
		},
		{
			desc:  "limit matches",
			input: []byte("\nfoobar\nbarfoo\n"),
			regex: regexp.MustCompile("foo"),
			limit: 1,
			results: &grepResults{
				matches: []grepMatch{
					{line: "foobar", lineno: int64(2)},
				},
			},
		},
		{
			desc:    "no matches",
			input:   []byte("\nfoobar\nbarfoo\n"),
			regex:   regexp.MustCompile("baz"),
			results: &grepResults{},
		},
		{
			desc:    "no matches",
			input:   []byte("\nfoobar\nbarfoo\n"),
			regex:   regexp.MustCompile("baz"),
			results: &grepResults{},
		},
		{
			desc:    "binary input",
			input:   []byte{0xcf, 0xfa, 0xed, 0xfe, 0x7, 0x0, 0x0, 0x1, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xd, 0x0, 0x0, 0x0, 0xa0, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x48, 0x0, 0x0, 0x0, 0x5f, 0x5f, 0x50, 0x41, 0x47, 0x45, 0x5a, 0x45, 0x52, 0x4f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x78, 0x2, 0x0, 0x0, 0x5f, 0x5f, 0x54, 0x45, 0x58, 0x54, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x4f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x4f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x5f, 0x54, 0x45, 0x58, 0x54, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x8a, 0x48, 0x2a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
			regex:   regexp.MustCompile("foo"),
			results: &grepResults{isBinary: true},
		},
	}

	for _, tt := range tests {
		tt := tt
		t.Run(tt.desc, func(t *testing.T) {
			t.Parallel()

			var reader io.Reader
			if tt.input != nil {
				reader = bytes.NewReader(tt.input)
			}
			got, err := grep(reader, tt.regex, tt.limit)
			if err != nil {
				t.Fatal(err)
			}
			if want := tt.results; !reflect.DeepEqual(want, got) {
				t.Errorf("Expected\n%v\ngot\n%v", want, got)
			}
		})
	}
}
